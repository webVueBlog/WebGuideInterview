(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{753:function(v,t,_){"use strict";_.r(t);var a=_(6),M=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"腾讯一面virtualdom的优势在哪里"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#腾讯一面virtualdom的优势在哪里"}},[v._v("#")]),v._v(" 腾讯一面VirtualDom的优势在哪里")]),v._v(" "),_("p",[v._v("Virtual Dom有patch算法，根据新旧vnode比较经过优化查找到不同的节点修补、更新。不会暴力的直接覆盖DOM。")]),v._v(" "),_("p",[v._v("Virtual Dom优势在于直接频繁的操作DOM效率远低于操作JavaScript的效率，使用JavaScript的成本取代DOM成本。")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("频繁操作DOM会导致大量的回流和重绘，会造成网页的卡顿。")]),v._v(" "),_("p",[v._v("Virtual Dom将DOM节点抽象为一个JS对象，同时只保留了核心的属性，对Virtual Dom的操作比直接操作DOM更为高效，同时Virtual Dom还配合使用diff算法，每次操作时会比较新老节点的不同，计算出渲染为真实dom 的最小代价操作，再渲染为真实DOM。")]),v._v(" "),_("p",[v._v("实际上这是一种利用JS运算成本来换取DOM执行成本的操作，而JS的运算速度快很多，所以这是一种比较划算的做法。")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("「Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果DOM操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。")]),v._v(" "),_("p",[v._v("首先我们需要知道：")]),v._v(" "),_("ul",[_("li",[v._v("DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）")]),v._v(" "),_("li",[v._v("JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，")]),v._v(" "),_("li",[v._v("引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。")])]),v._v(" "),_("p",[v._v("其次是 VDOM 和真实 DOM 的区别和优化：")]),v._v(" "),_("ul",[_("li",[v._v("虚拟 DOM 不会立马进行排版与重绘操作")]),v._v(" "),_("li",[v._v("虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进- 行排版与重绘，减少过多DOM节点排版与重绘损耗")]),v._v(" "),_("li",[v._v("虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部")])]),v._v(" "),_("p",[v._v("以前也常认为是虚拟DOM会比原生快，后来在知乎上看到这篇文章：https://www.zhihu.com/question/31809713\n才明白虚拟DOM的目的是为了能 声明式、基于状态驱动UI的开发，除此之外，它还可以渲染除 DOM 以外的 backend，比如 ReactNative")]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("p",[v._v("网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？")]),v._v(" "),_("p",[v._v("这里面有好几个方面的问题。")]),v._v(" "),_("ol",[_("li",[v._v("原生 DOM 操作 vs. 通过框架封装操作。")])]),v._v(" "),_("p",[v._v("这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？")]),v._v(" "),_("p",[v._v("在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("对 React 的 Virtual DOM 的误解。")])]),v._v(" "),_("p",[v._v("React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。")]),v._v(" "),_("p",[v._v("我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：")]),v._v(" "),_("p",[v._v("innerHTML:  render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)")]),v._v(" "),_("p",[v._v("Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)")]),v._v(" "),_("p",[v._v("Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。")]),v._v(" "),_("p",[v._v("前面说了，和 DOM 操作比起来，js 计算是极其便宜的。")]),v._v(" "),_("p",[v._v("这才是为什么要有 Virtual DOM：")]),v._v(" "),_("p",[v._v("它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("你依然可以用类似 innerHTML 的思路去写你的应用。")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("MVVM vs. Virtual DOM")])]),v._v(" "),_("p",[v._v("相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。")]),v._v(" "),_("p",[v._v("MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。")]),v._v(" "),_("p",[v._v("但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。")]),v._v(" "),_("p",[v._v('MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 "scope" 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。')]),v._v(" "),_("p",[v._v("这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。")]),v._v(" "),_("p",[v._v("假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。")]),v._v(" "),_("p",[v._v("相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。")]),v._v(" "),_("p",[v._v("Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。")]),v._v(" "),_("p",[v._v("或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。")]),v._v(" "),_("p",[v._v("在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。")]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("性能比较也要看场合")])]),v._v(" "),_("p",[v._v("在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。")]),v._v(" "),_("p",[v._v("Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。")]),v._v(" "),_("p",[v._v("Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。")]),v._v(" "),_("p",[v._v("初始渲染：Virtual DOM > 脏检查 >= 依赖收集")]),v._v(" "),_("p",[v._v("小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化")]),v._v(" "),_("p",[v._v("大量数据更新：脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM（无法/无需优化）>> MVVM 无优化")]),v._v(" "),_("p",[v._v("不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。")]),v._v(" "),_("p",[v._v("在我看来 Virtual DOM 真正的价值从来都不是性能，而是它")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("为函数式的 UI 编程方式打开了大门；")])]),v._v(" "),_("li",[_("p",[v._v("可以渲染到 DOM 以外的 backend，比如 ReactNative。")])])]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("总结")])]),v._v(" "),_("p",[v._v("以上这些比较，更多的是对于框架开发研究者提供一些参考。")]),v._v(" "),_("p",[v._v("主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。")])])}),[],!1,null,null,null);t.default=M.exports}}]);