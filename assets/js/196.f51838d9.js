(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{789:function(a,t,s){"use strict";s.r(t);var v=s(6),n=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"作用域是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域是什么"}},[a._v("#")]),a._v(" 作用域是什么")]),a._v(" "),s("p",[a._v("设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域。")]),a._v(" "),s("h3",{attrs:{id:"编译原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[a._v("#")]),a._v(" 编译原理")]),a._v(" "),s("p",[a._v("在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译”。")]),a._v(" "),s("ul",[s("li",[a._v("分词/词法分析（Tokenizing/Lexing）")])]),a._v(" "),s("p",[a._v("这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成 为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。")]),a._v(" "),s("p",[a._v("分词（tokenizing）和词法分析（Lexing）之间的区别")]),a._v(" "),s("p",[a._v("主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。")]),a._v(" "),s("ul",[s("li",[a._v("解析/语法分析（Parsing）")])]),a._v(" "),s("p",[a._v("这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。")]),a._v(" "),s("ul",[s("li",[a._v("代码生成")])]),a._v(" "),s("p",[a._v("将 AST 转换为可执行代码的过程称被称为代码生成。")]),a._v(" "),s("blockquote",[s("p",[a._v("在 语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化 等。对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时 间内。")])]),a._v(" "),s("h3",{attrs:{id:"理解作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解作用域"}},[a._v("#")]),a._v(" 理解作用域")]),a._v(" "),s("p",[a._v("理解 JavaScript 的工作原理")]),a._v(" "),s("ul",[s("li",[a._v("引擎")])]),a._v(" "),s("p",[a._v("从头到尾负责整个 JavaScript 程序的编译及执行过程。")]),a._v(" "),s("ul",[s("li",[a._v("编译器")])]),a._v(" "),s("p",[a._v("引擎的好朋友之一，负责语法分析及代码生成等脏活累活。")]),a._v(" "),s("ul",[s("li",[a._v("作用域")])]),a._v(" "),s("p",[a._v("引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限")]),a._v(" "),s("div",{staticClass:"language-JavaScript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编 译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。")]),a._v(" "),s("p",[a._v("伪代码进行概括：“为一个变量分配内 存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("事实上编译器会进行如下处理。")])]),s("ol",[s("li",[s("p",[a._v("遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。")])]),a._v(" "),s("li",[s("p",[a._v("接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量")])])]),a._v(" "),s("p",[a._v("总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。")]),a._v(" "),s("blockquote",[s("p",[a._v("引擎执行怎样的查找")])]),a._v(" "),s("p",[a._v("当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。")]),a._v(" "),s("p",[a._v("RHS 理解成 retrieve his source value 取到它的源值")]),a._v(" "),s("div",{staticClass:"language-JavaScript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2 ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("ul",[s("li",[a._v("引擎：为 foo 进行 RHS 引用。")]),a._v(" "),s("li",[a._v("作用域：编译器刚声明了它。它是一个函数")]),a._v(" "),s("li",[a._v("引擎：我来执行一下 foo")]),a._v(" "),s("li",[a._v("引擎：我需要为 a 进行 LHS 引用")]),a._v(" "),s("li",[a._v("作用域：编译器最近把它声名为 foo 的一个形式参数了")]),a._v(" "),s("li",[a._v("引擎：现在我要把 2 赋值给 a。")]),a._v(" "),s("li",[a._v("引擎：我要为 console 进行 RHS 引用")]),a._v(" "),s("li",[a._v("作用域：console 是个内置对象。")]),a._v(" "),s("li",[a._v("引擎：有 log(..)。是一个函数。")]),a._v(" "),s("li",[a._v("引擎：对 a 的 RHS 引用，我来把 a 的值，也就是 2，传递进 log(..)。")])]),a._v(" "),s("h3",{attrs:{id:"作用域嵌套"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套"}},[a._v("#")]),a._v(" 作用域嵌套")]),a._v(" "),s("p",[a._v("作用域是根据名称查找变量的一套规则。")]),a._v(" "),s("p",[a._v("当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。")]),a._v(" "),s("h3",{attrs:{id:"异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[a._v("#")]),a._v(" 异常")]),a._v(" "),s("p",[a._v("如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型")]),a._v(" "),s("p",[a._v("当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。")]),a._v(" "),s("h3",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),s("ul",[s("li",[a._v("作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。")]),a._v(" "),s("li",[a._v("如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。")]),a._v(" "),s("li",[a._v("不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);