(window.webpackJsonp=window.webpackJsonp||[]).push([[174],{766:function(e,t,p){"use strict";p.r(t);var s=p(6),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,p=e._self._c||t;return p("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[p("h2",{attrs:{id:"高德一面一个tcp连接能发几个http请求"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#高德一面一个tcp连接能发几个http请求"}},[e._v("#")]),e._v(" 高德一面一个tcp连接能发几个http请求")]),e._v(" "),p("p",[e._v("如果是http1.0，一个tcp连接只能发一个http请求，如果是http1.1及以上，引入了持续连接的概念，所以一个tcp连接能发多个http请求。")]),e._v(" "),p("p",[e._v("只要不断开，就能够持续发。")]),e._v(" "),p("p",[e._v("因为是HTTP/1.1开始才有Connection 头，所以在1.1之前，只能是一个，在1.1以上，便是随便发。")]),e._v(" "),p("p",[e._v("在RFC2616里有这么一句话：")]),e._v(" "),p("p",[e._v('A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.')]),e._v(" "),p("p",[e._v("意思就是支持持久连接的客户端可以让请求变成pipeline，就是跟水管一样一直出水而不用等结果~")]),e._v(" "),p("p",[e._v("HTTP/1.0 :一个tcp连接只能发一个http请求。每次服务端返回响应后TCP连接会断开。")]),e._v(" "),p("p",[e._v("HTTP/1.1: 默认开启Connection: keep-alive，一个TCP连接可以发多个http请求，但是多个请求是串行执行。（注意区别TCP的keep-alive）")]),e._v(" "),p("p",[e._v("HTTP/2: 引入了多路复用技术 和二进制分帧，同个域名下的请求只需要占用一个 TCP 连接，请求和响应是并行执行。(详细请看：[https://developer.51cto.com/art/201910/604255.htm])")]),e._v(" "),p("p",[e._v("如果是HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP连接即会断开，因此一个TCP发送一个HTTP请求，但是有一种情况可以将一条TCP连接保持在活跃状态，那就是通过Connection和Keep-Alive首部，在请求头带上 Connection: Keep-Alive ，并且可以通过Keep-Alive 通用首部中指定的，用逗号分隔的选项调节keep-alive的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于Keep-Alive连接的限制和规则；")]),e._v(" "),p("p",[e._v("而如果是HTTP 1.1 版本协议，支持了长连接，因此只要TCP连接不断开，便可以一直发送HTTP请求，持续不断，没有上限；")]),e._v(" "),p("p",[e._v("同样，如果是HTTP 2.0 版本协议，支持多用复用，一个TCP连接是可以并发多个HTTP请求的，同样也是支持长连接，因此只要不断开TCP的连接，HTTP请求数也是可以没有上限地持续发送，")])])}),[],!1,null,null,null);t.default=n.exports}}]);