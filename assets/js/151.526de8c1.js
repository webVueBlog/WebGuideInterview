(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{743:function(t,e,s){"use strict";s.r(e);var r=s(6),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"字节-怎么与服务端保持连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字节-怎么与服务端保持连接"}},[t._v("#")]),t._v(" 字节-怎么与服务端保持连接")]),t._v(" "),s("p",[t._v("和服务端保持连接，最简单粗暴的方法就是通过请求轮询保持跟服务端的通信，客户端不光要花成本维护定时轮询器，还会使得服务器压力变大，所以不推荐。")]),t._v(" "),s("p",[t._v("还有一种可以借助请求超时的设置，将超时时间设置一个足够大的值，客户端发起连接后，只要服务端不返回消息，整个连接阶段都会受到阻塞，所以这种方式也不推荐。")]),t._v(" "),s("p",[t._v("最后一种是WebSocket，当服务器完成协议从HTTP到WebSocket的升级后，服务端可以主动推送信息给客户端，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通信，直到关闭连接，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/7887063/77540187-98497480-6edd-11ea-89f2-91f64f670f5f.png",alt:""}})])])}),[],!1,null,null,null);e.default=a.exports}}]);