(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{748:function(t,v,_){"use strict";_.r(v);var e=_(6),p=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"浏览器重排与重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器重排与重绘"}},[t._v("#")]),t._v(" 浏览器重排与重绘")]),t._v(" "),_("p",[t._v("回流：")]),t._v(" "),_("p",[t._v("触发条件：")]),t._v(" "),_("p",[t._v("当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。")]),t._v(" "),_("p",[t._v("例如以下操作会触发回流：")]),t._v(" "),_("p",[t._v("1、一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。")]),t._v(" "),_("p",[t._v("2、使 DOM 节点发生增减或者移动。")]),t._v(" "),_("p",[t._v("3、读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。\n4、调用 window.getComputedStyle 方法。")]),t._v(" "),_("p",[t._v("回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过样式计算、生成布局树、建立图层树、再到生成绘制列表以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。")]),t._v(" "),_("p",[t._v("重绘：")]),t._v(" "),_("p",[t._v("触发条件：")]),t._v(" "),_("p",[t._v("当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。")]),t._v(" "),_("p",[t._v("重绘过程：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过生存布局树和建立图层树的阶段，直接到生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。")]),t._v(" "),_("p",[t._v("如何避免触发回流和重绘：")]),t._v(" "),_("p",[t._v("1、避免频繁使用 style，而是采用修改class的方式。")]),t._v(" "),_("p",[t._v("2、将动画效果应用到position属性为absolute或fixed的元素上。")]),t._v(" "),_("p",[t._v("3、也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘")]),t._v(" "),_("p",[t._v("4、使用createDocumentFragment进行批量的 DOM 操作。")]),t._v(" "),_("p",[t._v("5、对于 resize、scroll 等进行防抖/节流处理。")]),t._v(" "),_("p",[t._v("6、避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),t._v(" "),_("p",[t._v("7、利用 CSS3 的transform、opacity、filter这些属性可以实现合成的效果，也就是GPU加速。")])])}),[],!1,null,null,null);v.default=p.exports}}]);