(window.webpackJsonp=window.webpackJsonp||[]).push([[450],{1044:function(t,s,e){"use strict";e.r(s);var a=e(6),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"深入响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入响应式原理"}},[t._v("#")]),t._v(" 深入响应式原理")]),t._v(" "),e("h3",{attrs:{id:"_1-响应式对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-响应式对象"}},[t._v("#")]),t._v(" 1. 响应式对象")]),t._v(" "),e("p",[t._v("响应式对象：Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("Object.defineProperty")]),t._v(" "),e("p",[t._v("直接在一个对象上定义一个新属性，或者修改一个对象的现有属性")])]),e("ul",[e("li",[t._v("initState：在 Vue 的初始化阶段，_init 方法执行的时候，会执行 initState(vm) 方法\n"),e("ul",[e("li",[t._v("主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作\n"),e("ul",[e("li",[t._v("initProps：props 的初始化主要过程，就是遍历定义的 props 配置\n"),e("ul",[e("li",[t._v("一个是调用 defineReactive 方法把每个 prop 对应的值变成响应式，可以通过 vm._props.xxx 访问到定义 props 中对应的属性。")]),t._v(" "),e("li",[t._v("通过 proxy 把 vm._props.xxx 的访问代理到 vm.xxx 上")])])]),t._v(" "),e("li",[t._v("initData\n"),e("ul",[e("li",[t._v("一个是对定义 data 函数返回对象的遍历，通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上；")]),t._v(" "),e("li",[t._v("另一个是调用 observe 方法观测整个 data 的变化，把 data 也变成响应式，可以通过 vm._data.xxx 访问到定义 data 返回函数中对应的属性")])])]),t._v(" "),e("li",[t._v("proxy：代理的作用是把 props 和 data 上的属性代理到 vm 实例上\n"),e("ul",[e("li",[t._v("proxy 方法的实现很简单，通过 Object.defineProperty 把 "),e("code",[t._v("target[sourceKey][key]")]),t._v(" 的读写变成了对 "),e("code",[t._v("target[key]")]),t._v(" 的读写。")]),t._v(" "),e("li",[t._v("比如 data ，对 vm._data.xxxx 的读写变成了对 vm.xxxx 的读写。")])])]),t._v(" "),e("li",[t._v("总结\n"),e("ul",[e("li",[t._v("无论是 props 或是 data 的初始化都是把它们变成响应式对象")])])])])])])])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("initProps：props")]),t._v(" "),e("p",[t._v("initData")]),t._v(" "),e("p",[t._v("proxy")])]),e("ul",[e("li",[t._v("observe ：功能就是用来监测数据的变化\n"),e("ul",[e("li",[t._v("observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例")])])]),t._v(" "),e("li",[t._v("Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新")]),t._v(" "),e("li",[t._v("defineReactive： 功能就是定义一个响应式对象，给对象动态添加 getter 和 setter。")])]),t._v(" "),e("blockquote",[e("p",[t._v("总结")])]),t._v(" "),e("p",[t._v("响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新")]),t._v(" "),e("h3",{attrs:{id:"_2-依赖收集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-依赖收集"}},[t._v("#")]),t._v(" 2. 依赖收集")]),t._v(" "),e("p",[t._v("依赖收集：响应式对象 getter 相关的逻辑就是做依赖收集")]),t._v(" "),e("ul",[e("li",[t._v("Dep：整个 getter 依赖收集的核心\n"),e("ul",[e("li",[t._v("Dep 实际上就是对 Watcher 的一种管理。而且在同一时间只能有一个全局的 Watcher 被计算")])])]),t._v(" "),e("li",[t._v("Watcher\n"),e("ul",[e("li",[t._v("Watcher 是一个 Class，定义了一些和 Dep 相关的属性， 还定义了一些原型的方法，和依赖收集相关的有 get、addDep 和 cleanupDeps 方法。")]),t._v(" "),e("li",[t._v("总结\n"),e("ul",[e("li",[t._v("在添加 deps 的订阅过程，可以通过 id 去重避免重复订阅。在每次添加完新的订阅，会移除掉旧的订阅")])])])])]),t._v(" "),e("li",[t._v("总结\n"),e("ul",[e("li",[t._v("收集依赖就是订阅数据变化的 watcher 的收集。收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 Watcher 和 Dep 就是一个非常经典的观察者设计模式的实现")])])])]),t._v(" "),e("h3",{attrs:{id:"_3-派发更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-派发更新"}},[t._v("#")]),t._v(" 3. 派发更新")]),t._v(" "),e("ul",[e("li",[t._v("修改值的时候，会触发 setter ，会对新设置的值变成一个响应式对象，并通过 dep.notify() 通知所有的订阅者\n"),e("ul",[e("li",[t._v("做派发更新的时候的一个优化的点，它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue")]),t._v(" "),e("li",[t._v("总结\n"),e("ul",[e("li",[t._v("当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程，这个过程又利用了队列做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数。")])])])])])]),t._v(" "),e("h3",{attrs:{id:"_4-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-nexttick"}},[t._v("#")]),t._v(" 4. nextTick")]),t._v(" "),e("ul",[e("li",[t._v("JS 运行机制\n"),e("ul",[e("li",[t._v("JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤\n"),e("ul",[e("li",[t._v("所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。")]),t._v(" "),e("li",[t._v('主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。')]),t._v(" "),e("li",[t._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。')]),t._v(" "),e("li",[t._v("主线程不断重复上面的第三步。")]),t._v(" "),e("li",[t._v("代码演示 macro task 和 micro task 执行顺序")])])])])])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("macroTask "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" macroTaskQueue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. Handle current MACRO-TASK")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMacroTask")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. Handle all MICRO-TASK")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("microTask "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" microTaskQueue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMicroTask")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("microTask"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 常见的 micro task 有 MutationObsever 和 Promise.then。")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("p",[t._v("总结")]),t._v(" "),e("p",[t._v("主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("vue 中 nextTick 实现")])]),e("ul",[e("li",[t._v("申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。")]),t._v(" "),e("li",[t._v("对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0；")]),t._v(" "),e("li",[t._v("而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。")]),t._v(" "),e("li",[t._v("nextTick 把传入的回调函数 cb 压入 callbacks 数组，最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数。")])]),t._v(" "),e("p",[t._v("这里使用 callbacks 而不是直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("next-tick.js 还对外暴露了 withMacroTask 函数，它是对函数做一层包装，确保函数执行过程中对数据任意的修改，触发变化执行 nextTick 的时候强制走 macroTimerFunc。比如对于一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task。")])]),e("p",[t._v("总结")]),t._v(" "),e("p",[t._v("对 nextTick 的分析，并结合上一节的 setter 分析，我们了解到数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。这就是我们平时在开发的过程中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。")]),t._v(" "),e("p",[t._v("Vue.js 提供了 2 种调用 nextTick 的方式，一种是全局 API Vue.nextTick，一种是实例上的方法 vm.$nextTick，无论我们使用哪一种，最后都是调用 next-tick.js 中实现的 nextTick 方法。")]),t._v(" "),e("h3",{attrs:{id:"_5-检测变化的注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-检测变化的注意事项"}},[t._v("#")]),t._v(" 5. 检测变化的注意事项")]),t._v(" "),e("p",[t._v("对象添加属性")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("对于使用 Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的")])]),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" vm "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("data")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("a")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// vm.b 是非响应的")]),t._v("\nvm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[t._v("要用 Vue.set 方法")]),t._v(" "),e("p",[t._v("set 方法是在对象上设置属性。添加新属性和如果属性不存在，通过 defineReactive(ob.value, key, val) 把新添加的属性变成响应式对象，然后再通过 ob.dep.notify() 手动的触发依赖通知。")]),t._v(" "),e("blockquote",[e("p",[t._v("数组")])]),t._v(" "),e("p",[t._v("Vue 也是不能检测到以下变动的数组")]),t._v(" "),e("ul",[e("li",[t._v("当你利用索引直接设置一个项时，例如："),e("code",[t._v("vm.items[indexOfItem] = newValue")]),t._v(" "),e("ul",[e("li",[t._v("可以使用："),e("code",[t._v("Vue.set(example1.items, indexOfItem, newValue)")])])])]),t._v(" "),e("li",[t._v("当你修改数组的长度时，例如："),e("code",[t._v("vm.items.length = newLength")]),t._v(" "),e("ul",[e("li",[t._v("可以使用 "),e("code",[t._v("vm.items.splice(newLength)")])])])])]),t._v(" "),e("p",[t._v("总结")]),t._v(" "),e("p",[t._v("vue 通过 arrayMethods 继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写，重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知，这就很好地解释了之前的示例中调用 vm.items.splice(newLength) 方法可以检测到变化。")]),t._v(" "),e("h3",{attrs:{id:"_6-计算属性-vs-侦听属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-计算属性-vs-侦听属性"}},[t._v("#")]),t._v(" 6. 计算属性 VS 侦听属性")]),t._v(" "),e("ol",[e("li",[t._v("computd")])]),t._v(" "),e("p",[t._v("计算属性本质上就是一个 computed watcher，确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染。")]),t._v(" "),e("p",[t._v("computed watcher")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("watch")])]),t._v(" "),e("ul",[e("li",[t._v("本质上侦听属性也是基于 Watcher 实现的，它是一个 user watcher\n"),e("ul",[e("li",[t._v("deep watcher")]),t._v(" "),e("li",[t._v("user watcher")]),t._v(" "),e("li",[t._v("通过 vm.$watch 创建的 watcher 是一个 user watcher，其实它的功能很简单，在对 watcher 求值以及在执行回调函数的时候，会处理一下错误")]),t._v(" "),e("li",[t._v("computed watcher")]),t._v(" "),e("li",[t._v("sync watcher")])])])]),t._v(" "),e("p",[t._v("总结")]),t._v(" "),e("p",[t._v("计算属性本质上是 computed watcher，而侦听属性本质上是 user watcher。就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。")]),t._v(" "),e("h3",{attrs:{id:"_7-组件更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-组件更新"}},[t._v("#")]),t._v(" 7. 组件更新")]),t._v(" "),e("p",[t._v("组件更新：过程的核心就是新旧 vnode diff，对新旧节点相同以及不同的情况分别做不同的处理。")]),t._v(" "),e("ul",[e("li",[t._v("新旧节点不同")]),t._v(" "),e("li",[t._v("新旧 vnode 不同，本质上是要替换已存在的节点。\n"),e("ul",[e("li",[t._v("创建新节点\n"),e("ul",[e("li",[t._v("以当前旧节点为参考节点，创建新的节点，并插入到 DOM 中")])])]),t._v(" "),e("li",[t._v("更新父的占位符节点")]),t._v(" "),e("li",[t._v("删除旧节点\n"),e("ul",[e("li",[t._v("删除节点就是遍历待删除的 vnodes 做删除")])])])])]),t._v(" "),e("li",[t._v("新旧节点相同")]),t._v(" "),e("li",[t._v("updateChildren")])])])}),[],!1,null,null,null);s.default=r.exports}}]);