(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{791:function(t,s,a){"use strict";a.r(s);var i=a(6),r=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"关于this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于this"}},[t._v("#")]),t._v(" 关于this")]),t._v(" "),a("h3",{attrs:{id:"为什么要用this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用this"}},[t._v("#")]),t._v(" 为什么要用this")]),t._v(" "),a("p",[t._v("this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用")]),t._v(" "),a("h3",{attrs:{id:"误解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#误解"}},[t._v("#")]),t._v(" 误解")]),t._v(" "),a("ul",[a("li",[t._v("指向自身")]),t._v(" "),a("li",[t._v("它的作用域")])]),t._v(" "),a("p",[t._v("还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments. callee 来引用当前正在运行的函数对象。")]),t._v(" "),a("p",[t._v("这是唯一一种可以从匿名函数对象 内部引用自身的方法。")]),t._v(" "),a("p",[t._v("this 在任何情况下都不指向函数的词法作用域。")]),t._v(" "),a("p",[t._v("作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。")]),t._v(" "),a("h3",{attrs:{id:"this到底是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this到底是什么"}},[t._v("#")]),t._v(" this到底是什么")]),t._v(" "),a("p",[t._v("this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式")]),t._v(" "),a("p",[t._v("当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。")]),t._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("ul",[a("li",[t._v("this 既不指向函数自身也不指向函数的词法作用域")]),t._v(" "),a("li",[t._v("this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用")])])])}),[],!1,null,null,null);s.default=r.exports}}]);